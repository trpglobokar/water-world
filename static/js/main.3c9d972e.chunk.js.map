{"version":3,"sources":["water-world.js","serviceWorker.js","index.js"],"names":["MapContainer","styled","div","_templateObject","MapControls","_templateObject2","SliderLabel","_templateObject3","MapControlsSpacer","_templateObject4","WaterWorld","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","coolStyle","feature","elevation","properties","isBelowWaterLevel","state","waterLevel","fillColor","weight","opacity","color","fillOpacity","map","L","center","zoom","minZoom","maxBounds","geoJson","topoContors","style","addTo","_this2","eachLayer","layer","newStyle","setStyle","_this3","react_default","a","createElement","id","Slider","orientation","defaultValue","valueLabelDisplay","valueLabelFormat","x","concat","aria-labelledby","onChange","_event","value","setState","step","marks","min","max","Component","Boolean","window","location","hostname","match","ReactDOM","render","water_world_WaterWorld","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"89rtMAOA,IAAMA,EAAeC,IAAOC,IAAVC,KAIZC,EAAcH,IAAOC,IAAVG,KAWXC,EAAcL,IAAOC,IAAVK,KAIXC,EAAoBP,IAAOC,IAAVO,KAiBFC,cACnB,SAAAA,EAAaC,GAAO,IAAAC,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAAL,IAClBE,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAAH,GAAAQ,KAAAH,KAAMJ,KAkCRQ,UAAY,SAAAC,GACV,IAAMC,EAAYD,EAAQE,WAAWD,UAC/BE,EAAoBF,EAAYT,EAAKY,MAAMC,WAMjD,MAAO,CACLC,UALgBH,EAAoB,UAAY,OAMhDI,OAJ2B,IAAdN,EAAkB,EAAI,EAKnCO,QAAS,GACTC,MAAO,OACPC,YARkBP,EAAoB,EAAI,KApC5CX,EAAKY,MAAQ,CACXC,WAAY,GALIb,mFAWlBG,KAAKgB,IAAMC,IAAED,IAAI,MAAO,CACtBE,OAAQ,CAAC,IAAK,IACdC,KAAM,EACNC,QAAS,EACTC,UAAW,CACP,CAAC,IAAK,KACN,EAAE,GAAI,QAQZrB,KAAKsB,QAAUL,IAAEK,QAAQC,EAAa,CAAEC,MAAOxB,KAAKI,YAAaqB,MAAMzB,KAAKgB,kDAGzD,IAAAU,EAAA1B,KACnBA,KAAKsB,QAAQK,UAAU,SAAAC,GACrB,IAAMC,EAAWH,EAAKtB,UAAUwB,EAAMvB,SACtCuB,EAAME,SAASD,sCAsBV,IAAAE,EAAA/B,KACP,OACEgC,EAAAC,EAAAC,cAAA,WACEF,EAAAC,EAAAC,cAACjD,EAAD,CAAckD,GAAG,QACjBH,EAAAC,EAAAC,cAAC7C,EAAD,KACE2C,EAAAC,EAAAC,cAACzC,EAAD,KACEuC,EAAAC,EAAAC,cAAC3C,EAAD,iBACWyC,EAAAC,EAAAC,cAAA,WACRlC,KAAKS,MAAMC,WAFd,SAIAsB,EAAAC,EAAAC,cAACE,EAAA,EAAD,CACEC,YAAY,WACZC,aAAc,EACdC,kBAAkB,OAClBC,iBAAkB,SAAAC,GAAC,SAAAC,OAAOD,EAAP,OACnBE,kBAAgB,kBAChBC,SAAU,SAACC,EAAQC,GACjBf,EAAKgB,SAAS,CAACrC,WAAYoC,KAE7BE,KAAM,IACNC,OAAK,EACLC,IAAK,EACLC,IAAK,gBA5EqBC,aC/BpBC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO3B,EAAAC,EAAAC,cAAC0B,EAAD,MAAgBC,SAASC,eAAe,SD2HlD,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC","file":"static/js/main.3c9d972e.chunk.js","sourcesContent":["import React, { Component } from \"react\"\nimport L from \"leaflet\"\nimport topoContors from \"./static/topo-contours.json\"\nimport { Slider } from \"@material-ui/core\"\nimport styled from \"styled-components\"\n\n\nconst MapContainer = styled.div`\n  height: 100vh;\n  background-color: #aad3df;\n`\nconst MapControls = styled.div`\n  height: calc(100vh - 32px);\n  max-height: 400px;\n  width: 120px;\n  background-color: #fff;\n  position: fixed;\n  top: 16px;\n  right: 16px;\n  z-index: 999;\n  border-radius: 4px;\n`\nconst SliderLabel = styled.div`\n  text-align: center;\n  margin-bottom: 16px;\n`\nconst MapControlsSpacer = styled.div`\n  padding: 16px;\n  height: calc(100% - 32px);\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  & .MuiSlider-valueLabel {\n    top: -48px;\n    left: calc(-50% + -12px);\n    &>span {\n      width: 48px;\n      height: 48px;\n    }\n  }\n`\n\nexport default class WaterWorld extends Component {\n  constructor (props) {\n    super(props)\n    //const classes = useStyles()\n\n    this.state = {\n      waterLevel: 0\n    }\n  }\n\n  componentDidMount() {\n    // create map\n    this.map = L.map(\"map\", {\n      center: [42, -90],\n      zoom: 3,\n      minZoom: 2,\n      maxBounds: [\n          [90, -290],\n          [-68, 172]\n      ]\n    })\n\n    /*L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {\n      attribution: '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n    }).addTo(map)*/\n\n    this.geoJson = L.geoJson(topoContors, { style: this.coolStyle }).addTo(this.map)\n  }\n\n  componentDidUpdate() {\n    this.geoJson.eachLayer(layer => {\n      const newStyle = this.coolStyle(layer.feature)\n      layer.setStyle(newStyle)\n    })\n  }\n\n  coolStyle = feature => {\n    const elevation = feature.properties.elevation\n    const isBelowWaterLevel = elevation < this.state.waterLevel\n  \n    const fillColor = isBelowWaterLevel ? \"#aad3df\" : \"#060\"\n    const fillOpacity = isBelowWaterLevel ? 1 : 0.3\n    const weight = elevation === 0 ? 1 : 0\n\n    return {\n      fillColor,\n      weight,\n      opacity: 0.3,\n      color: \"#fff\",\n      fillOpacity,\n    }\n  }\n\n\n  render() {\n    return (\n      <div>\n        <MapContainer id=\"map\" />\n        <MapControls>\n          <MapControlsSpacer>\n            <SliderLabel>\n              Sea Level<br />\n              {this.state.waterLevel} Feet\n            </SliderLabel>\n            <Slider\n              orientation=\"vertical\"\n              defaultValue={0}\n              valueLabelDisplay=\"auto\"\n              valueLabelFormat={x => `${x}ft`}\n              aria-labelledby=\"vertical-slider\"\n              onChange={(_event, value) => {\n                this.setState({waterLevel: value})\n              }}\n              step={800}\n              marks\n              min={0}\n              max={20000}\n            />\n          </MapControlsSpacer>\n        </MapControls>\n      </div>\n    )\n  }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './static/index.css';\nimport WaterWorld from './water-world';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<WaterWorld />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}